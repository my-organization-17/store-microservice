// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.2
// source: store-item.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { wrappers } from "protobufjs";
import { Observable } from "rxjs";

export const protobufPackage = "store_item.v1";

/** declaration of GetStoreItemsByCategoryIdWithOptionRequest message */
export interface GetStoreItemsByCategoryIdWithOptionRequest {
  categoryId: string;
  language: string;
}

/** Message representing a list of store items with options */
export interface StoreItemListWithOption {
  data: StoreItemWithOption[];
}

/** Message representing a store item with flattened translations and variants */
export interface StoreItemWithOption {
  id: string;
  brand?: string | null | undefined;
  slug: string;
  isAvailable: boolean;
  sortOrder: number;
  expectedDate?: Date | null | undefined;
  categoryId: string;
  title: string;
  description?: string | null | undefined;
  detailedDescription?: string | null | undefined;
  images: ItemImage[];
  variants: ItemVariant[];
  prices: ItemBasePrice[];
  attributes: ItemInfoAttribute[];
}

/** Message representing an informational attribute (no price impact) */
export interface ItemInfoAttribute {
  name: string;
  value: string;
}

/** Message representing a product variant (one per attribute value) */
export interface ItemVariant {
  id: string;
  attributeName: string;
  attributeValue: string;
  regularPrice?: string | null | undefined;
  discountPrice?: string | null | undefined;
  currency: string;
}

/** Message representing a base price for items without variants */
export interface ItemBasePrice {
  priceType: string;
  value: string;
  currency: string;
}

/** Message representing an image for a store item */
export interface ItemImage {
  id: string;
  url: string;
  alt?: string | null | undefined;
  sortOrder: number;
}

export const STORE_ITEM_V1_PACKAGE_NAME = "store_item.v1";

wrappers[".google.protobuf.Timestamp"] = {
  fromObject(value: Date) {
    return { seconds: value.getTime() / 1000, nanos: (value.getTime() % 1000) * 1e6 };
  },
  toObject(message: { seconds: number; nanos: number }) {
    return new Date(message.seconds * 1000 + message.nanos / 1e6);
  },
} as any;

/** StoreItemService defines the gRPC service for managing store items. */

export interface StoreItemServiceClient {
  /** rpc to get store items by category ID with options for a specific language */

  getStoreItemsByCategoryIdWithOption(
    request: GetStoreItemsByCategoryIdWithOptionRequest,
  ): Observable<StoreItemListWithOption>;
}

/** StoreItemService defines the gRPC service for managing store items. */

export interface StoreItemServiceController {
  /** rpc to get store items by category ID with options for a specific language */

  getStoreItemsByCategoryIdWithOption(
    request: GetStoreItemsByCategoryIdWithOptionRequest,
  ): Promise<StoreItemListWithOption> | Observable<StoreItemListWithOption> | StoreItemListWithOption;
}

export function StoreItemServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getStoreItemsByCategoryIdWithOption"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StoreItemService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StoreItemService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STORE_ITEM_SERVICE_NAME = "StoreItemService";
